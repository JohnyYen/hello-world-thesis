\chapter{\chapterSecond}
%\addcontentsline{toc}{chapter}{\chapterSecond}
En este capítulo se presenta el diseño integral de la solución, partiendo de los requisitos funcionales y no funcionales, los casos de uso que estructuran la interacción entre actores y el sistema, así como la arquitectura y los patrones de diseño empleados. Este diseño constituye la hoja de ruta técnica que garantiza la coherencia entre los objetivos planteados y la implementación del sistema.

\section{Diseño del Videojuego}

El diseño del videojuego educativo constituye un componente esencial dentro de la solución propuesta, al ser el medio principal mediante el cual se materializa el proceso de enseñanza-aprendizaje gamificado. Su concepción parte de una cuidadosa integración entre los elementos lúdicos, pedagógicos y narrativos, de modo que la experiencia del jugador no solo resulte atractiva y motivadora, sino también coherente con los objetivos de aprendizaje de la programación. En esta sección se describen los aspectos fundamentales que guiaron el diseño del videojuego, organizados en tres dimensiones: la selección del género, la definición de las mecánicas y el desarrollo de la narrativa.

\subsection{Selección del Género}

El género seleccionado para el videojuego es una \textbf{novela visual con elementos de puzzle}, una combinación que permite equilibrar la inmersión narrativa con la resolución activa de problemas. La elección de la novela visual se sustenta en su capacidad para construir historias significativas y emocionalmente envolventes, facilitando la empatía del jugador con los personajes y el contexto educativo. Este formato resulta especialmente adecuado para entornos de aprendizaje, pues permite presentar los contenidos de manera contextualizada, guiando al jugador a través de diálogos, decisiones y situaciones que estimulan la reflexión y el razonamiento crítico. Además, el ritmo pausado y la estructura secuencial de las novelas visuales favorecen la introducción gradual de conceptos teóricos, adaptándose al nivel de comprensión del estudiante y fortaleciendo la relación entre narrativa y aprendizaje.

Por otro lado, la inclusión de \textit{puzzles} añade la dimensión interactiva y cognitiva necesaria para fomentar el pensamiento lógico, la planificación y la resolución de problemas, habilidades fundamentales en el ámbito de la programación y las ciencias computacionales. A través de estos desafíos, el jugador no solo aplica los conocimientos adquiridos, sino que también desarrolla estrategias de análisis y experimentación que refuerzan el aprendizaje activo. Este componente lúdico genera un ciclo de retroalimentación constante entre la acción y la reflexión, promoviendo la exploración y la creatividad como medios para alcanzar la solución correcta.

La fusión de ambos géneros —la narrativa introspectiva de la novela visual y la exigencia cognitiva del puzzle— permite construir una experiencia de aprendizaje equilibrada, inmersiva y desafiante. Esta combinación evita la monotonía y potencia la motivación intrínseca del estudiante, al ofrecerle una historia con propósito y un entorno interactivo donde sus decisiones tienen consecuencias tangibles. En este sentido, la elección de este formato responde a la necesidad de diseñar un videojuego que no solo enseñe contenidos de programación, sino que también despierte la curiosidad, el compromiso y el sentido de logro del jugador, pilares esenciales para un aprendizaje profundo y significativo.


\subsection{Selección de Mecánicas}

Las \textbf{mecánicas de juego} fueron diseñadas con un enfoque didáctico que integra el aprendizaje de la programación dentro de la propia dinámica interactiva, de modo que el progreso en el juego depende directamente de la comprensión y aplicación de los conceptos aprendidos. Cada nivel del videojuego representa un \textit{contenido específico de programación} vinculado a una situación del mundo real, lo que permite contextualizar el conocimiento y fomentar la transferencia a entornos prácticos. En estos escenarios, el jugador debe emplear bloques de código visual que simbolizan estructuras, funciones y principios del lenguaje de programación, con el fin de resolver un problema, automatizar una tarea o guiar a los personajes hacia un objetivo determinado.  

Esta mecánica combina la lógica del pensamiento computacional con la manipulación visual, reduciendo la carga cognitiva y facilitando la comprensión de conceptos abstractos como variables, bucles o condicionales. El sistema de retroalimentación inmediata, implementado tras cada acción o decisión del jugador, permite una reflexión constante sobre el propio desempeño, reforzando el aprendizaje mediante el error y la experimentación. De esta forma, el jugador aprende a razonar, depurar y optimizar soluciones de manera natural, tal como lo haría en un entorno real de programación.  

Asimismo, el diseño por niveles introduce un sistema de dificultad gradual, donde cada etapa amplía y profundiza los conocimientos adquiridos previamente, garantizando que el reto se mantenga equilibrado con las habilidades del jugador. Este principio de progresión controlada busca mantener el interés y la motivación, evitando tanto la frustración por exceso de dificultad como el aburrimiento por falta de desafío. En conjunto, estas mecánicas no solo promueven un aprendizaje activo y autónomo, sino que también contribuyen a generar un \textit{estado de flujo} sostenido, en el cual el estudiante se siente plenamente concentrado, motivado y comprometido con su propio proceso de aprendizaje.


\subsection{Narrativa del Juego}

La \textbf{narrativa} del videojuego se desarrolla en torno a la historia de un estudiante de nuevo ingreso en la Facultad de Ingeniería Informática, quien se enfrenta a los retos académicos, sociales y emocionales que implica adaptarse a la vida universitaria. Desde su llegada a la facultad, el protagonista debe afrontar situaciones cotidianas —como el trabajo en equipo, la entrega de proyectos o la preparación de exámenes— en las que los conocimientos de programación adquieren un papel fundamental para la resolución de problemas y la superación de desafíos. A través de diálogos interactivos y decisiones ramificadas, el jugador participa activamente en el desarrollo de la historia, influyendo en el curso de los acontecimientos y fortaleciendo su sentido de agencia dentro del relato.  

El progreso narrativo se entrelaza con el avance académico del personaje: cada nivel o capítulo introduce nuevos contenidos de programación que el jugador debe dominar para continuar la trama. Este enfoque permite que la enseñanza ocurra de manera orgánica, integrada a la experiencia emocional y a la evolución personal del protagonista. De este modo, los logros del jugador no se limitan a superar obstáculos técnicos, sino que simbolizan el crecimiento y la autoconfianza del estudiante frente a los desafíos del aprendizaje.  

La narrativa busca generar una conexión emocional entre el jugador y su avatar, permitiendo que los logros dentro del juego se asocien con experiencias de superación y aprendizaje real. Los personajes secundarios —como compañeros, profesores y tutores— enriquecen el relato al representar distintas perspectivas sobre el proceso educativo, fomentando la empatía y el sentido de comunidad. Además, el entorno universitario se configura como un espacio simbólico que refleja los valores del esfuerzo, la colaboración y la curiosidad intelectual.  

En conjunto, la historia no solo cumple una función estética o de ambientación, sino que actúa como un vehículo pedagógico que da sentido al proceso formativo. Al integrar el conocimiento técnico dentro de una narrativa significativa, el videojuego transforma la experiencia de aprendizaje en una vivencia emocionalmente resonante, donde cada decisión, error o acierto contribuye a la construcción del conocimiento y al desarrollo personal del jugador.

% \subsection{Elementos de Gamificación Aplicados}

\section{Requisitos Funcionales}

Los requisitos funcionales definen qué debe hacer el sistema desde el punto de vista del usuario o de otro sistema externo \cite{sommerville_software_2011,pressman_ingenierisoftware_2013}. En este caso, se han dividido los requisitos funcionales según el módulo al que pertenecen ya sea \textit{Hello World!!} o la \textit{interfaz web docente}.

\subsubsection*{Módulo del Estudiante}

\begin{longtable}{|p{0.1\linewidth}|p{0.8\linewidth}|}
	\hline
	\textbf{ID} & \textbf{Descripción del Requisito} \\
	\hline
	\endfirsthead
	
	\multicolumn{2}{c}{\tablename\ \thetable\ -- continuación desde la página anterior} \\
	\hline
	\textbf{ID} & \textbf{Descripción del Requisito} \\
	\hline
	\endhead
	
	\hline
	\endfoot
	
	\hline
	\endlastfoot

    \multicolumn{2}{|c|}{\textbf{A. Evaluación y Progreso}} \\
    \hline
	RF1 & El sistema debe evaluar el desempeño del jugador en cada nivel utilizando métricas como tiempo, errores y eficiencia de código. \\
	\hline
	RF2 & El sistema debe registrar automáticamente estos datos para análisis posterior. \\
	\hline
	RF9 & El sistema debe guardar automáticamente el progreso del jugador tras finalizar un nivel o salir del juego, sin perder información. \\
	\hline
	RF13 & Al completar un nivel, el sistema debe mostrar una puntuación numérica o cualitativa basada en criterios como número de errores, eficiencia de la solución y tiempo. \\
	\hline
	RF14 & El jugador debe tener acceso a un resumen de su progreso general: puntaje promedio, tiempo total invertido, conceptos dominados, niveles completados. \\
	\hline

    \multicolumn{2}{|c|}{\textbf{B. Adaptación y Personalización}} \\
    \hline
	RF3 & El sistema debe adaptar automáticamente el nivel si el jugador no cumple los objetivos establecidos. \\
	\hline
	RF4 & La adaptación puede incluir simplificar el objetivo, reducir la complejidad del código requerido o dar pistas adicionales. \\
	\hline
	RF7 & El sistema debe ajustar la dificultad de los niveles siguientes basándose en el historial de desempeño del jugador. \\
	\hline
	RF8 & El jugador debe poder configurar opciones del juego, como volumen del sonido, resolución de pantalla, idioma, modo de color. \\
	\hline

    \multicolumn{2}{|c|}{\textbf{C. Contenido Pedagógico}} \\
    \hline
	RF5 & Cada nivel debe estar asociado a un tema específico de programación y esta asociación debe ser clara tanto para el estudiante como para el profesor. \\
	\hline
	RF10 & Al inicio de cada nivel, el sistema debe mostrar una clase introductoria que explique el concepto de programación asociado. \\
	\hline
	RF11 & El sistema debe permitir al jugador construir soluciones usando bloques de programación visual. \\
	\hline
	RF12 & Los bloques deben representar acciones lógicas (condiciones, ciclos, variables). \\
	\hline

    \multicolumn{2}{|c|}{\textbf{D. Interacción y Retroalimentación}} \\
    \hline
	RF6 & Tras cada acción del jugador (ejecutar, reiniciar, completar), el sistema debe mostrar retroalimentación visual o textual inmediata. \\
	\hline
	RF17 & El sistema debe ofrecer un tutorial interactivo al primer inicio que enseñe las mecánicas básicas del juego. \\
	\hline

    \multicolumn{2}{|c|}{\textbf{E. Progresión y Acceso a Niveles}} \\
    \hline
	RF15 & El sistema debe presentar los niveles en un orden progresivo que refleje el avance pedagógico. \\
	\hline
	RF16 & No se debe permitir acceder a niveles posteriores sin haber superado los anteriores (salvo excepciones definidas por el profesor). \\
	\hline
	RF18 & El jugador debe poder repetir niveles ya completados para mejorar su puntuación o entender mejor el concepto. \\
	\hline

\end{longtable}



\subsubsection*{Módulo del Profesor}

\begin{longtable}{|p{0.1\linewidth}|p{0.8\linewidth}|}
	\hline
	\textbf{RF} & \textbf{Descripción del Requisito Funcional} \\
	\hline
	\endfirsthead
	
	\multicolumn{2}{c}{\tablename\ \thetable\ -- continuación} \\
	\hline
	\textbf{RF} & \textbf{Descripción del Requisito Funcional} \\
	\hline
	\endhead
	
	\hline
	\endfoot
	
	\hline
	\endlastfoot

    \multicolumn{2}{|c|}{\textbf{A. Monitoreo y Seguimiento del Estudiante}} \\
    \hline
	RF1 & Mostrar un resumen consolidado del progreso individual y grupal de los estudiantes. \\
	\hline
	RF2 & Incluir métricas detalladas como niveles completados, errores comunes y tiempo promedio por nivel. \\
	\hline
	RF5 & Generar gráficos comparativos de rendimiento entre estudiantes (por ejemplo: barras, líneas, mapas de calor). \\
	\hline
	RF8 & Permite visualizar el historial completo de progreso de cada estudiante, incluyendo puntuaciones y tiempos. \\
	\hline
	RF9 & Notificar al profesor cuando un estudiante no alcanza el umbral mínimo de rendimiento en varios niveles consecutivos. \\
	\hline
	RF15 & Consultar estadísticas globales del curso, como porcentaje de niveles completados, promedio de puntuación, etc. \\
	\hline

    \multicolumn{2}{|c|}{\textbf{B. Comunicación y Retroalimentación}} \\
    \hline
	RF3 & Permitir al profesor enviar comentarios personalizados a estudiantes individuales o grupos enteros. \\
	\hline
	RF13 & Recibir notificaciones sobre nuevos mensajes o actualizaciones de progreso enviadas por el sistema o los estudiantes. \\
	\hline
	RF14 & Establecer objetivos personalizados para uno o más estudiantes dentro de un curso o grupo. \\
	\hline

    \multicolumn{2}{|c|}{\textbf{C. Creación y Gestión de Contenido}} \\
    \hline
	RF4 & Brindar un editor intuitivo para crear, modificar o eliminar niveles utilizando bloques predefinidos. \\
	\hline
	RF6 & Asignar niveles específicos a estudiantes o grupos según su desempeño. \\
	\hline
	RF10 & Crear exámenes tipo basados en niveles ya existentes, con opción de configurar tiempo límite y número de intentos. \\
	\hline
	RF11 & Importar/exportar niveles entre diferentes cursos o instituciones educativas (futuro). \\
	\hline

    \multicolumn{2}{|c|}{\textbf{D. Reportes y Exportación}} \\
    \hline
	RF7 & Exportar reportes de progreso de estudiantes en formatos estándar (PDF, CSV). \\
	\hline

    \multicolumn{2}{|c|}{\textbf{E. Integración con Plataformas Externas}} \\
    \hline
	RF12 & Integrar con plataformas LMS (Moodle, Google Classroom) para autenticación única y sincronización de datos de progreso. \\
	\hline

\end{longtable}


\section{Requisitos No Funcionales}

Los requisitos no funcionales, a diferencia de los funcionales, definen las restricciones de calidad, seguridad, usabilidad y desempeño del sistema  \cite{sommerville_software_2011,pressman_ingenierisoftware_2013}. En la siguiente tabla se muestran los requisitos no funcionales identificados durante la etapa de análisis del proyecto.

\begin{longtable}{|p{0.08\linewidth}|p{0.38\linewidth}|p{0.18\linewidth}|p{0.28\linewidth}|}
	\hline
	\textbf{ID} & \textbf{Descripción del Requisito} & \textbf{Categoría} & \textbf{Criterio de Aceptación} \\
	\hline
	\endfirsthead
	
	\multicolumn{4}{c}{\tablename\ \thetable\ -- continuación desde la página anterior} \\
	\hline
	\textbf{ID} & \textbf{Descripción del Requisito} & \textbf{Categoría} & \textbf{Criterio de Aceptación} \\
	\hline
	\endhead
	
	\hline
	\endfoot
	
	\hline
	\endlastfoot
	
	RNF1 & El sistema debe garantizar la protección de datos sensibles mediante autenticación segura (JWT) para información crítica. & Seguridad & Pruebas de penetración y verificación de que las contraseñas nunca se almacenan en texto plano. \\
	\hline
	
	RNF2 & El sistema debe responder ante acciones del usuario en menos de 2 segundos bajo carga normal de hasta 200 usuarios concurrentes. & Rendimiento & Pruebas de estrés que demuestren que el 90\% de las solicitudes cumplen el tiempo máximo de respuesta. \\
	\hline
	
	RNF3 & La interfaz del juego y del panel docente debe ser intuitiva y accesible para usuarios sin experiencia en videojuegos. & Usabilidad & Al menos un 80\% de los usuarios de prueba deben completar una tarea básica sin asistencia en menos de 5 minutos. \\
	\hline
	
	RNF4 & El sistema debe permitir escalar horizontalmente su infraestructura backend en caso de aumento de estudiantes registrados. & Escalabilidad & Prueba de despliegue en contenedores donde se añadan nuevos nodos sin interrumpir el servicio. \\
	\hline
	
	RNF5 & El módulo del estudiante debe ejecutarse en dispositivos móviles Android/iOS. & Compatibilidad & Pruebas en al menos 3 dispositivos móviles con OS distintos. \\
	\hline
	
	RNF6 & El sistema debe mantener una disponibilidad mínima del 95\% durante el periodo lectivo. & Disponibilidad & Monitoreo de uptime mensual que no registre más de 5\% de tiempo fuera de servicio. \\
	\hline
	
	RNF7 & El código debe estar organizado y documentado para facilitar mantenimiento y futuras actualizaciones. & Mantenibilidad & Revisión de código donde al menos el 90\% de las funciones incluyan documentación y comentarios explicativos. \\
	\hline
	
	RNF8 & El sistema debe integrarse con plataformas LMS estándar (Moodle, Google Classroom) para sincronizar datos de progreso. & Interoperabilidad & Pruebas de integración exitosas que confirmen autenticación única (SSO) y exportación de datos en formato estándar. \\
	\hline
	
	RNF9 & El sistema debe cumplir con pautas básicas de accesibilidad web (WCAG 2.1 AA), incluyendo modo oscuro y ajuste de texto. & Accesibilidad & Validación con herramientas automáticas y pruebas con al menos 2 usuarios con discapacidad visual leve. \\
	\hline
\end{longtable}


% ----------------------------------------------
\section{Casos de Uso}

\subsection{Actores del Sistema}

Un actor representa cualquier persona u otra entidad externa que interactúa con el sistema  \cite{sommerville_software_2011,pressman_ingenierisoftware_2013}. En este proyecto, se identifican dos actores principales:

\begin{itemize}
	\item \textbf{Estudiante}: Es el usuario principal del módulo \textit{Hello World}. Su rol es interactuar con los niveles del juego, recibir retroalimentación sobre su desempeño y avanzar a través de un sistema progresivo de aprendizaje.
	
	\item \textbf{Profesor}: Usuario principal del módulo \textit{Teacher Core}, encargado de supervisar el progreso de los estudiantes, asignar niveles personalizados y recibir notificaciones relevantes sobre el desempeño académico de sus alumnos.
\end{itemize}

Ambos actores interactúan con el sistema de manera diferente, pero están interconectados mediante un backend compartido que permite la sincronización de datos y la comunicación bidireccional entre ellos.

\subsection{Diagrama de Casos de Uso del Sistema}

El diagrama de caso de uso, ver figura \ref{fig:helloworld-use-case}, del módulo \textit{Hello World!!!} ilustra las acciones disponibles para el estudiante, tales como:

\begin{itemize}
	\item Jugar niveles educativos.
	\item Recibir retroalimentación inmediata.
	\item Guardar automáticamente el progreso.
	\item Repetir niveles completados.
	\item Recibir sugerencias ante fallos reiterados.
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth, height=1\textheight, keepaspectratio]{src/Hello_World Use Case}
	\caption[Diagrama de Caso de Uso: Hello World]{Diagrama de Caso de Uso para el módulo correspondiente al estudiante}
	\label{fig:helloworld-use-case}
\end{figure}

Por otro lado, el diagrama del módulo \textit{Teacher Core} ilustra las acciones que puede realizar el profesor dentro de la interfaz web. Entre ellas se encuentran:

\begin{itemize}
	\item Visualizar el progreso individual y grupal de los estudiantes.
	
	\item Asignar niveles específicos.
	
	\item Consultar estadísticas y generar reportes.
	
	\item Recibir notificaciones automáticas sobre bajo rendimiento.
	
	\item Enviar mensajes o comentarios personalizados.
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.85\linewidth, height=0.65\textheight, keepaspectratio]{"src/Teacher Core Use Case"}
	\caption[Diagrama de Caso de Uso para el Módulo correspondiente al profesor]{}
	\label{fig:teacher-core-use-case}
\end{figure}

\subsection{Descripción de alto nivel de los casos de uso}

\subsubsection*{Módulo del Estudiante}

% =======================
% Caso de uso 1
% =======================
\begin{table}[H]
\centering
\begin{tabular}{|p{0.25\linewidth}|p{0.65\linewidth}|}
\hline
\textbf{ID} & CU1 \\
\hline
\textbf{Nombre} & Jugar nivel \\
\hline
\textbf{Actor(es)} & Estudiante \\
\hline
\textbf{Relaciones} & 
\begin{itemize}
    \item \textbf{include}: Evaluar desempeño, Construir solución con bloques, Guardar automáticamente el nivel
    \item \textbf{extend}: Ofrecer sugerencias tras fallos repetitivos
\end{itemize} \\
\hline
\textbf{Descripción Breve} & El estudiante interactúa con un nivel del juego, resolviendo el reto de programación mediante bloques visuales, recibiendo retroalimentación inmediata y guardando su progreso. \\
\hline
\textbf{RF Relacionados} & RF1, RF2, RF3, RF4, RF6, RF7, RF11, RF12, RF13 \\
\hline
\end{tabular}
\caption{Caso de uso CU1: Jugar nivel}
\end{table}

% =======================
% Caso de uso 2
% =======================
\begin{table}[H]
\centering
\begin{tabular}{|p{0.25\linewidth}|p{0.65\linewidth}|}
\hline
\textbf{ID} & CU2 \\
\hline
\textbf{Nombre} & Seleccionar nivel \\
\hline
\textbf{Actor(es)} & Estudiante \\
\hline
\textbf{Relaciones} & 
\begin{itemize}
    \item \textbf{extend}: Ver clase introductoria
\end{itemize} \\
\hline
\textbf{Descripción Breve} & El estudiante puede elegir un nivel disponible dentro de la progresión definida por el sistema, con opción de acceder al contenido teórico previo. \\
\hline
\textbf{RF Relacionados} & RF5, RF10, RF15, RF16 \\
\hline
\end{tabular}
\caption{Caso de uso CU2: Seleccionar nivel}
\end{table}

% =======================
% Caso de uso 3
% =======================
\begin{table}[H]
\centering
\begin{tabular}{|p{0.25\linewidth}|p{0.65\linewidth}|}
\hline
\textbf{ID} & CU3 \\
\hline
\textbf{Nombre} & Ver nivel de clase introductoria al contenido \\
\hline
\textbf{Actor(es)} & Estudiante \\
\hline
\textbf{Relaciones} & Extensión de \textit{Seleccionar nivel} \\
\hline
\textbf{Descripción Breve} & El sistema presenta material teórico introductorio antes de iniciar el nivel, reforzando el aprendizaje del concepto de programación asociado. \\
\hline
\textbf{RF Relacionados} & RF5, RF10 \\
\hline
\end{tabular}
\caption{Caso de uso CU3: Ver clase introductoria}
\end{table}

% =======================
% Caso de uso 4
% =======================
\begin{table}[H]
\centering
\begin{tabular}{|p{0.25\linewidth}|p{0.65\linewidth}|}
\hline
\textbf{ID} & CU4 \\
\hline
\textbf{Nombre} & Sincronizar datos del estudiante con el servidor \\
\hline
\textbf{Actor(es)} & Estudiante, Sistema (worker) \\
\hline
\textbf{Relaciones} & Independiente, ejecutado automáticamente cuando hay conexión a Internet \\
\hline
\textbf{Descripción Breve} & El sistema asegura que el progreso, puntuaciones y configuraciones locales del estudiante se actualicen en el servidor central para mantener la persistencia de datos. \\
\hline
\textbf{RF Relacionados} & RF2, RF9 \\
\hline
\end{tabular}
\caption{Caso de uso CU4: Sincronizar datos}
\end{table}


\subsubsection*{Módulo del Profesor}

% =======================
% Caso de uso 1
% =======================
\begin{table}[H]
\centering
\begin{tabular}{|p{0.25\linewidth}|p{0.65\linewidth}|}
\hline
\textbf{ID} & CU5 \\
\hline
\textbf{Nombre} & Obtener un resumen detallado del progreso de los estudiantes \\
\hline
\textbf{Actor(es)} & Profesor \\
\hline
\textbf{Relaciones} & 
\begin{itemize}
    \item \textbf{extend}: Exportar reporte de estadísticas del progreso
\end{itemize} \\
\hline
\textbf{Descripción Breve} & Permite al profesor acceder a un informe completo sobre el rendimiento de los estudiantes, incluyendo métricas de desempeño, niveles alcanzados y evolución en el aprendizaje. \\
\hline
\textbf{RF Relacionados} & RF20, RF21, RF22, RF23 \\
\hline
\end{tabular}
\caption{Caso de uso CU5: Obtener un resumen detallado del progreso de los estudiantes}
\end{table}

% =======================
% Caso de uso 2
% =======================
\begin{table}[H]
\centering
\begin{tabular}{|p{0.25\linewidth}|p{0.65\linewidth}|}
\hline
\textbf{ID} & CU6 \\
\hline
\textbf{Nombre} & Notificar al profesor \\
\hline
\textbf{Actor(es)} & Sistema \\
\hline
\textbf{Relaciones} & 
\begin{itemize}[leftmargin=*]
    \item Generalización: Notificar mensajes del sistema sobre el desempeño
    \item Generalización: Notificar cuando un estudiante no sobrepasa el umbral mínimo
\end{itemize} \\
\hline
\textbf{Descripción Breve} & El sistema envía notificaciones al profesor sobre el estado de rendimiento de los estudiantes, destacando problemas recurrentes o bajo desempeño. \\
\hline
\textbf{RF Relacionados} & RF24, RF25, RF26 \\
\hline
\end{tabular}
\caption{Caso de uso CU6: Notificar al profesor}
\end{table}

% =======================
% Caso de uso 3
% =======================
\begin{table}[H]
\centering
\begin{tabular}{|p{0.25\linewidth}|p{0.65\linewidth}|}
\hline
\textbf{ID} & CU7 \\
\hline
\textbf{Nombre} & Confeccionar niveles especiales para los estudiantes \\
\hline
\textbf{Actor(es)} & Profesor \\
\hline
\textbf{Relaciones} & Generalización: Modificar niveles a estudiantes específicos \\
\hline
\textbf{Descripción Breve} & Permite al profesor crear y adaptar niveles personalizados para estudiantes o grupos, ajustando la dificultad y los contenidos según necesidades específicas. \\
\hline
\textbf{RF Relacionados} & RF27, RF28, RF29 \\
\hline
\end{tabular}
\caption{Caso de uso CU7: Confeccionar niveles especiales para los estudiantes}
\end{table}

% =======================
% Caso de uso 4
% =======================
\begin{table}[H]
\centering
\begin{tabular}{|p{0.25\linewidth}|p{0.65\linewidth}|}
\hline
\textbf{ID} & CU8 \\
\hline
\textbf{Nombre} & Autenticar en el sistema \\
\hline
\textbf{Actor(es)} & Profesor \\
\hline
\textbf{Relaciones} & Independiente, requisito previo para el resto de funcionalidades del módulo del profesor. \\
\hline
\textbf{Descripción Breve} & Permite al profesor acceder al sistema mediante credenciales seguras, habilitando las funcionalidades asociadas al seguimiento y personalización del aprendizaje de los estudiantes. \\
\hline
\textbf{RF Relacionados} & RF18, RF19 \\
\hline
\end{tabular}
\caption{Caso de uso CU8: Autenticar en el sistema}
\end{table}

% ------------------------------------------------

\section{Arquitectura del Sistema}

El diseño arquitectónico de la plataforma propuesta se describe utilizando el \textbf{Modelo C4}, creado por Simon Brown \cite{brown2018c4}. Este modelo surge como una alternativa moderna y simplificada al uso extensivo de diagramas UML tradicionales, priorizando la comprensión del sistema por parte de todos los actores del proyecto —desde desarrolladores hasta interesados no técnicos— sin sacrificar precisión técnica. 

El modelo C4 se basa en una jerarquía de cuatro niveles que permiten visualizar el sistema con diferentes grados de detalle:

\begin{itemize}
    \item \textbf{Nivel 1: Diagrama de Contexto}. Presenta el sistema como una “caja negra”, mostrando los actores externos (usuarios u otros sistemas) que interactúan con él, y el tipo de relaciones o flujos de información existentes.
    \item \textbf{Nivel 2: Diagrama de Contenedores}. Descompone el sistema en sus principales contenedores (aplicaciones, bases de datos, servicios web, interfaces) y muestra cómo se comunican entre sí.
    \item \textbf{Nivel 3: Diagrama de Componentes}. Profundiza dentro de un contenedor específico, mostrando los componentes principales, sus responsabilidades y las relaciones entre ellos.
    \item \textbf{Nivel 4: Diagrama de Código}. Ofrece una vista detallada de la implementación, incluyendo clases, interfaces y relaciones a nivel de código fuente.
\end{itemize}

A diferencia de UML, el modelo C4 no pretende describir exhaustivamente todos los aspectos estructurales o de comportamiento del software, sino ofrecer una \textbf{visión jerárquica y comprensible} del sistema. Su simplicidad gráfica facilita la comunicación entre equipos interdisciplinarios, evitando la sobrecarga de notación que caracteriza a UML.

Dado que el objetivo de esta tesis es presentar una \textbf{propuesta arquitectónica de la plataforma educativa}, se utilizan únicamente los tres primeros niveles (Contexto, Contenedores y Componentes). Estos niveles son suficientes para representar de forma clara tanto la organización global del sistema como la interacción entre sus módulos y los elementos internos más relevantes, sin entrar en detalles de implementación de código.

\subsection{Arquitectura General}

La arquitectura general de la plataforma se estructura siguiendo los niveles de Contexto y Contenedores del modelo C4. Esta visión permite identificar las interacciones entre los distintos módulos que componen el sistema, así como su relación con los actores externos.

\textbf{Nivel 1: Diagrama de Contexto}

El sistema propuesto, denominado \textit{Plataforma Educativa Gamificada para la Enseñanza de la Programación}, se compone de dos actores principales: el \textbf{Estudiante} y el \textbf{Profesor}. Ambos interactúan con la plataforma a través de diferentes interfaces que comparten un backend común encargado de la persistencia y sincronización de datos.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{src/C4_Context}
    \caption{Diagrama de Contexto del Sistema.}
    \label{fig:c4_contexto}
\end{figure}

En este nivel se visualiza la interacción entre los actores y el sistema como una unidad. El estudiante utiliza el videojuego educativo, mientras que el profesor accede a la interfaz web para supervisar el progreso académico. El backend actúa como intermediario central, gestionando las comunicaciones, almacenamiento y autenticación de usuarios. 

\textbf{Nivel 2: Diagrama de Contenedores}

El siguiente nivel descompone la solución en sus principales contenedores de software, los cuales se comunican a través de una API RESTful implementada en el backend. Los contenedores identificados son:

\begin{itemize}
    \item \textbf{Frontend Estudiante (Hello World!!)}: Videojuego educativo desarrollado con \textit{Godot Engine}, que implementa mecánicas adaptativas para ajustar la dificultad de los niveles según el desempeño del jugador.
    \item \textbf{Frontend Profesor (Teacher Core)}: Aplicación web desarrollada en \textit{Next.js}, donde el docente puede visualizar métricas de progreso, asignar niveles personalizados y generar reportes.
    \item \textbf{API Backend}: Servicio central desarrollado en \textit{FastAPI (Python)}, encargado de procesar solicitudes, aplicar reglas de negocio y gestionar la persistencia de datos.
    \item \textbf{Base de Datos PostgreSQL}: Repositorio donde se almacenan usuarios, niveles, métricas de rendimiento y configuraciones del sistema.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{src/C4_Container}
    \caption{Diagrama de Contenedores del Sistema.}
    \label{fig:c4_contenedores}
\end{figure}

Este nivel refleja la separación de responsabilidades entre los distintos componentes del ecosistema: el videojuego se orienta a la experiencia educativa del estudiante, la aplicación web al monitoreo docente, y el backend como intermediario de servicios y sincronización.

\subsection{Arquitectura a Detalle por Módulo}

A continuación, se describen los diagramas de componentes (nivel 3 del modelo C4) correspondientes a cada uno de los módulos que conforman el sistema.

\subsubsection{Módulo Estudiante}

El módulo del estudiante se estructura en torno al patrón \textit{Modelo–Vista–Controlador} (MVC), adaptado al contexto de Godot. En este nivel, el diagrama de componentes detalla las principales unidades funcionales del videojuego, su relación y responsabilidades.

\begin{itemize}
    \item \textbf{GameManager}: Coordina el flujo del juego, maneja la lógica principal y las transiciones entre niveles.
    \item \textbf{LevelManager}: Controla la carga, ejecución y evaluación de los niveles.
    \item \textbf{HUDController}: Gestiona los elementos visuales de la interfaz y la retroalimentación al jugador.
    \item \textbf{ExecutionEngine}: Ejecuta la secuencia de bloques programáticos definidos por el jugador.
    \item \textbf{AdaptationSystem}: Ajusta la dificultad de los niveles en función del desempeño del estudiante.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{C4_Components_Godot.pdf}
    \caption{Diagrama de Componentes del Módulo Estudiante.}
    \label{fig:c4_estudiante}
\end{figure}

Este diseño facilita la extensibilidad del sistema, permitiendo incorporar nuevos tipos de niveles o mecánicas sin modificar la estructura base del videojuego. Además, la separación de responsabilidades asegura una mayor mantenibilidad y testabilidad del código.

\subsubsection{Módulo Profesor}

El \textbf{módulo del profesor} se concibe como una aplicación web desarrollada bajo una arquitectura cliente–servidor, orientada a ofrecer al docente un entorno integral de gestión, seguimiento y análisis del proceso de aprendizaje. Su diseño organiza las funcionalidades en componentes especializados que interactúan de manera coordinada para facilitar la supervisión del progreso estudiantil y la creación de contenidos educativos.  

Este módulo se estructura de forma que el docente pueda acceder a información consolidada sobre el rendimiento general de sus estudiantes, diseñar y adaptar actividades de aprendizaje según las necesidades del grupo, y generar reportes que apoyen la toma de decisiones pedagógicas. La comunicación entre la interfaz del usuario y el sistema central se realiza mediante una API REST, garantizando la sincronización eficiente de datos y la actualización en tiempo real de la información.  

En conjunto, la composición del módulo combina elementos de visualización, gestión de datos y generación de informes, integrados dentro de una interfaz intuitiva que prioriza la accesibilidad y la usabilidad. De este modo, el módulo del profesor no solo actúa como una herramienta de control y evaluación, sino también como un espacio de apoyo para la planificación docente y la personalización del aprendizaje.


\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{src/c4components_spa}
    \caption{Diagrama de Componentes del Módulo Profesor.}
    \label{fig:c4_profesor}
\end{figure}

El diseño modular del frontend docente facilita la integración con plataformas externas como Moodle o Google Classroom, garantizando interoperabilidad mediante autenticación única (SSO) y sincronización de progreso académico.

\subsubsection{API Backend}

El backend constituye el núcleo funcional de la plataforma, encargado de gestionar la lógica de negocio, la comunicación con la base de datos y la integración con los distintos módulos del sistema. Su diagrama de componentes refleja una arquitectura cuidadosamente diseñada bajo los principios de separación de responsabilidades, modularidad y escalabilidad, lo que garantiza un mantenimiento ágil y la posibilidad de incorporar nuevas funcionalidades sin comprometer la estabilidad del sistema. Además, esta estructura permite un procesamiento eficiente de las solicitudes provenientes del frontend, asegurando una respuesta rápida, segura y coherente con los objetivos pedagógicos de la plataforma.

% \begin{itemize}
%     \item \textbf{AuthService}: Gestiona la autenticación y autorización de usuarios mediante JWT.
%     \item \textbf{ProgressService}: Procesa y almacena los datos de avance y rendimiento del estudiante.
%     \item \textbf{LevelService}: Administra la creación, asignación y validación de niveles educativos.
%     \item \textbf{ReportService}: Expone endpoints para la generación de reportes solicitados por el módulo del profesor.
%     \item \textbf{IntegrationModule}: Facilita la conexión con sistemas externos LMS.
%     \item \textbf{Database Layer}: Encargada de la persistencia de datos en PostgreSQL.
% \end{itemize}

% \begin{figure}[H]
%     \centering
%     \includegraphics[width=0.95\textwidth,keepaspectratio]{src/C4_Components_API}
%     \caption{Diagrama de Componentes del API Backend.}
%     \label{fig:c4_backend}
% \end{figure}

\begin{figure}[H]
    \centering
    % Escala al ancho total del texto manteniendo proporción
    \includegraphics[width=\linewidth, keepaspectratio]{src/C4_Components_API.pdf}
    \caption{Diagrama de Componentes del API Backend.}
    \label{fig:c4_backend}
\end{figure}


% La API sigue el estándar RESTful y fue diseñada bajo los principios de arquitectura orientada a servicios, lo que permite escalar o reemplazar módulos de negocio sin afectar al resto del sistema. Cada servicio se comunica con el resto mediante interfaces bien definidas, garantizando un acoplamiento mínimo y una alta cohesión interna.

% ------------------------------------------------

\section{Principios y patrones de Diseño}

\subsection{Principios SOLID}

El acrónimo \textit{SOLID} agrupa cinco principios fundamentales de diseño orientado a objetos definidos por Robert C. Martin. Para este proyecto, se han implementado dos de ellos desde las capas iniciales de diseño:

\subsubsection{Principio de Responsabilidad Única}

Este principio establece que una clase debe tener únicamente debe cumplir una sola responsabilidad o función dentro del sistema, claramente delimitada.

En el módulo Estudiante se ha respetado este principio al separar claramente las responsabilidades:

\begin{enumerate}
	\item Las clases encargadas del manejo de interfaz (\texttt{GameManager}, \texttt{HUDController}) no contienen lógica de negocio ni acceso a datos.
	
	\item La lógica crítica del juego (\texttt{LevelManager}) está encapsulada en componentes independientes.
	
	\item El acceso a datos se realiza mediante repositorios, evitando que las entidades o servicios tengan múltiples responsabilidades.
	
	\item La clase \textit{ExecutionEngine} su única responsabilidad es la de ejecutar la secuencia de bloques.
\end{enumerate}

\subsubsection{Principio de Substitución de Liskov}

Este principio establece que una clase hija, debe ser utilizada en cualquier contexto donde es utilizado el padre, alterando solamente su funcionamiento.

Para el diseño del interprete de soluciones, se decidió utilizar este principio, permitiendo que sin importar que contexto\footnote{Digase contexto, a una representación lógica de un entorno físico, por ejemplo un contexto de cafetería que tiene listar de estudiante por atender o un contexto de librería con libros por organizar} se estuviese utilizando, el interprete ejecutaria correctamente todos los comandos/bloques

\subsubsection{Principio Abierto/Cerrado}

Este principio indica que las entidades del software deben estar abiertas para extensión, pero cerradas para modificación. Es decir, debería ser posible agregar nuevas funcionalidades sin modificar el código existente.

Aunque el sistema aún se encuentra en fase temprana, se han tomado decisiones que preparan el terreno para cumplir este principio:

\begin{enumerate}
	\item Se usan interfaces claras en la capa de repositorios, permitiendo que nuevos tipos de almacenamiento puedan integrarse sin modificar la lógica de negocio.
	
	\item Se han creado clases base para niveles educativos que pueden extenderse fácilmente para crear nuevos tipos de niveles sin alterar su comportamiento original.
	
	\item Se usa herencia y polimorfismo limitadamente, priorizando la composición cuando sea más apropiado.
\end{enumerate}

\subsection{Otros Principios de Diseño Aplicados}

Además de los principios SOLID, se han seguido otros patrones y buenas prácticas de diseño que complementan la solidez técnica del sistema.

\subsubsection{Principio DRY (Don't Repeat Yourself)}

Este principio establece que cada pieza de conocimiento o funcionalidad en un sistema debe tener una representación única y no ambigua. Su uso es esencial porque sienta las bases de la programación geneérica, utilizada en el desarrollo del backend.

\begin{enumerate}
	\item Se han creado funciones reutilizables para operaciones comunes como el cálculo de puntuaciones o la validación de bloques.
	
	\item Se evita duplicar código entre niveles similares; se prefiere usar configuraciones dinámicas o factorías de niveles.
	
	\item Métodos genéricos en la capa de infraestructura permiten reusar lógica de persistencia sin repetir código.
\end{enumerate}

\subsubsection{Ley de Demeter}

La Ley de Demeter sugiere que un componente debe interactuar solo con sus colaboradores directos, evitando cadenas largas de llamadas a métodos de otros objetos (\textit{"más de un punto"}).

Por ejemplo, en el proyecto se aplica de la siguiente forma: 
\begin{enumerate}
	\item  Se favorece el uso de métodos que ocultan la complejidad interna, ofreciendo una interfaz limpia y simple.
	
	\item En Godot, se han usado señales (\textit{signals}) para evitar acoplamiento directo entre nodos o escenas, con otras implementaciones lógicas.
\end{enumerate}

\subsubsection{Programar hacia Interfaces, no hacia Implementaciones}

Este principio promueve el uso de interfaces o contratos abstractos en lugar de depender de clases concretas, lo cual mejora la flexibilidad y la testabilidad del sistema. Hay que recalcar que en GDScript (Godot) no existen interfaces formales, pero se simulan mediante contratos y clases abstractas (ver figura[Muestra una imagen de una clase tipo interfaz, de como se implementa para que funcione como interfaz]) 

En la implementación del sistema, se emplea este principio de la siguiente forma:

\begin{itemize}
	\item Se definen interfaces claras en la capa de repositorios, como \texttt{IPlayerRepository}, \texttt{ILevelRepository}. La lógica de negocio utiliza estas interfaces para interactuar con los datos, sin importar cómo se implementan.
	
	\item Para que el interprete de soluciones, pueda operar sin importar el nivel, se abstrae de la implementación del contexto, mediante interfaces.
\end{itemize}

\subsection{Patrones de Diseño}

En el desarrollo del sistema se han implementado diversos patrones de diseño orientados a resolver problemas recurrentes de manera eficiente y a garantizar la mantenibilidad del software. A continuación, se detallan los principales:

% - Añadir diagrama global de clase
\subsubsection{Patrón Singleton}
Este patrón asegura que una clase tenga una única instancia global accesible. El \texttt{GameController} se implementa como un Singleton, centralizando la gestión del flujo del juego y evitando la creación de múltiples instancias que podrían generar inconsistencias en el estado global.

% - Añadir diagrama de clase del patrón

\subsubsection{Patrón Facade}
El patrón Facade provee una interfaz unificada que oculta la complejidad de subsistemas internos. Se utiliza para abstraer las interacciones con los sistemas LMS (Learning Management Systems), de manera que el módulo solo consuma las funciones necesarias sin depender de las implementaciones concretas.

% - Añadir diagrama de clase del patrón

\subsubsection{Patrón Abstract Factory}
Este patrón permite crear familias de objetos relacionados sin especificar sus clases concretas. Se aplica en la creación de acciones para el bloque \texttt{Ejecución}, permitiendo generar dinámicamente instancias de acciones sin necesidad de crear un bloque personalizado para cada una, lo que mejora la extensibilidad del sistema.

% - Añadir diagrama de clase del patrón

\subsubsection{Patrón Strategy}
El patrón Strategy define una familia de algoritmos y encapsula cada uno de ellos, permitiendo intercambiarlos en tiempo de ejecución. Se utiliza para modificar dinámicamente la estrategia de comunicación con LMS sin afectar la lógica de la aplicación. Asimismo, se aplica en la implementación de un \texttt{LevelController}, permitiendo definir distintos comportamientos según el nivel en que se encuentre el estudiante.

% - Añadir diagrama de clase del patrón
% ------------------------------------------------

\section{Modelo de despliegue}	

El modelo de despliegue representa la arquitectura física donde los componentes de software se ejecutan y cómo interactúan entre sí. A continuación se muestra el diagrama de despliegue:

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{../src/Deployement}
	\caption[Modelo de Despliegue]{Modelo de Despliegue}
	\label{fig:deployement}
\end{figure}

El diagrama analizado presenta una infraestructura heterogénea compuesta por múltiples nodos interconectados. En el núcleo del sistema se observa un servidor web implementado en FastAPI, encargado de gestionar tanto la autenticación de usuarios como la integración con sistemas de gestión de aprendizaje (LMS) mediante una API REST. Este componente actúa como puerta de entrada para las solicitudes provenientes de los clientes.

Paralelamente, el sistema incorpora un servidor de bases de datos independiente que utiliza PostgreSQL como motor principal. La separación física entre el servidor web y el servidor de bases de datos sigue las mejores prácticas de seguridad y permite una administración más eficiente de los recursos.

En el segmento móvil del diagrama, se especifican dos artefactos principales: una aplicación móvil genérica y un paquete APK específico, ambos dependientes de un entorno de ejecución Vulkan. Esto indica que la aplicación requiere capacidades gráficas, compatibles con dispositivos que soporten OpenGL ES 2.0/3.0 o Vulkan. Los requisitos técnicos detallados - 1GB de RAM, 500MB de almacenamiento y procesador de 1.7GHz - delinean el perfil mínimo de dispositivos móviles capaces de ejecutar la solución.

La capa de presentación representado mediante un navegador web que accede a la interfaz web del módulo de profesores. Este componente interactúa con el servidor web mencionado anteriormente, completando el flujo de información del sistema.

% - Agregar información sobre docker (Cuando toque)
% ---------------------------------------------


\section{Conclusiones parciales}

El presente capítulo permitió concretar el diseño integral de la plataforma educativa propuesta, partiendo de la identificación detallada de los requisitos funcionales y no funcionales que sustentan su desarrollo. Estos requisitos sirvieron como base para definir las capacidades esenciales del sistema, garantizando la alineación entre las necesidades pedagógicas del entorno educativo y las metas técnicas del proyecto. A partir de dichos requisitos se elaboraron los diagramas de casos de uso que describen las principales interacciones entre los actores —estudiantes y profesores— y el sistema. Estos diagramas proporcionan una representación clara de las funcionalidades requeridas y de los flujos de información dentro de la plataforma. El diseño arquitectónico, sustentado en el modelo C4, permitió obtener una visión estructurada y progresiva de la solución, abarcando desde la interacción de los usuarios con el sistema hasta la composición interna de los módulos. Esta representación ofrece una comprensión unificada de la arquitectura, facilitando su validación y futura evolución. Asimismo, la justificación de los principios y patrones de diseño —incluyendo SOLID, DRY y la programación orientada a interfaces— garantizó la mantenibilidad, escalabilidad y extensibilidad del sistema a mediano y largo plazo. El modelo de despliegue propuesto consolidó la organización física de los componentes en una infraestructura distribuida, lo que asegura la separación de responsabilidades, la seguridad de los datos y la optimización de recursos.
